#include "bench.h"
#include "csv.h"
#include "util.h"
#include "ascon_api.h"

#include <openssl/evp.h>
#include <openssl/sha.h>
#include <string.h>
#include <stdlib.h>

static int x25519_keypair(EVP_PKEY **out) {
    EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_X25519, NULL);
    if (!pctx) return 0;
    int ok = 0;
    if (EVP_PKEY_keygen_init(pctx) <= 0) goto out;
    if (EVP_PKEY_keygen(pctx, out) <= 0) goto out;
    ok = 1;
out:
    EVP_PKEY_CTX_free(pctx);
    return ok;
}

static int x25519_derive(EVP_PKEY *priv, EVP_PKEY *peer,
                         uint8_t *ss, size_t ss_cap, size_t *ss_len) {
    EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(priv, NULL);
    if (!ctx) return 0;
    int ok = 0;
    if (EVP_PKEY_derive_init(ctx) <= 0) goto out;
    if (EVP_PKEY_derive_set_peer(ctx, peer) <= 0) goto out;
    size_t len = 0;
    if (EVP_PKEY_derive(ctx, NULL, &len) <= 0) goto out;
    if (len > ss_cap) goto out;
    if (EVP_PKEY_derive(ctx, ss, &len) <= 0) goto out;
    *ss_len = len;
    ok = 1;
out:
    EVP_PKEY_CTX_free(ctx);
    return ok;
}

static void kdf_placeholder_sha256(const uint8_t *ss, size_t ss_len,
                                  uint8_t k16[16], uint8_t nonce16[16],
                                  uint64_t *kdf_ns) {
    uint8_t d[32];
    uint64_t t0 = now_ns_monotonic_raw();
    SHA256(ss, ss_len, d);
    memcpy(k16, d, 16);
    memcpy(nonce16, d + 16, 16);
    uint64_t t1 = now_ns_monotonic_raw();
    *kdf_ns = t1 - t0;
}

void run_x25519_ascon128a(const bench_config_t *cfg, csv_writer_t *csv) {
    int total = cfg->warmup + cfg->iterations;

    size_t ccap = cfg->payload_len + 16;
    uint8_t *c = malloc(ccap);
    uint8_t *m = malloc(cfg->payload_len);
    if (!c || !m) return;

    for (int i = 0; i < total; i++) {
        csv_row_t r; memset(&r, 0, sizeof(r));
        strncpy(r.Model, "ModelB_X25519", sizeof(r.Model)-1);
        r.Iteration = i - cfg->warmup;

        uint64_t t_begin = now_ns_monotonic_raw();
        r.Failed = 0;

        uint64_t t0 = now_ns_monotonic_raw();
        EVP_PKEY *srv = NULL, *cli = NULL;
        if (!x25519_keypair(&srv) || !x25519_keypair(&cli)) r.Failed = 1;
        uint64_t t1 = now_ns_monotonic_raw();

        uint8_t ss_cli[64], ss_srv[64];
        size_t ss_cli_len=0, ss_srv_len=0;

        if (!r.Failed && !x25519_derive(cli, srv, ss_cli, sizeof(ss_cli), &ss_cli_len)) r.Failed = 1;
        uint64_t t2 = now_ns_monotonic_raw();
        if (!r.Failed && !x25519_derive(srv, cli, ss_srv, sizeof(ss_srv), &ss_srv_len)) r.Failed = 1;
        uint64_t t3 = now_ns_monotonic_raw();

        r.KeyGen_ns = t1 - t0;
        r.Encaps_ns = t2 - t1;
        r.Decaps_ns = t3 - t2;

        if (!r.Failed && (ss_cli_len != ss_srv_len || memcmp(ss_cli, ss_srv, ss_cli_len) != 0)) r.Failed = 1;

        if (!r.Failed) {
            uint8_t k16[16], nonce16[16];
            kdf_placeholder_sha256(ss_srv, ss_srv_len, k16, nonce16, &r.KDF_ns);

            uint64_t te0 = now_ns_monotonic_raw();
            size_t clen = 0;
            if (ascon128a_aead_encrypt(c, &clen, cfg->payload, cfg->payload_len,
                                      (const uint8_t*)cfg->aad, strlen(cfg->aad),
                                      nonce16, k16) != 0) {
                r.Failed = 1;
            }
            uint64_t te1 = now_ns_monotonic_raw();

            uint64_t td0 = now_ns_monotonic_raw();
            size_t mlen = 0;
            if (!r.Failed && ascon128a_aead_decrypt(m, &mlen, c, clen,
                                                   (const uint8_t*)cfg->aad, strlen(cfg->aad),
                                                   nonce16, k16) != 0) {
                r.Failed = 1;
            }
            uint64_t td1 = now_ns_monotonic_raw();

            r.Encryption_ns = te1 - te0;
            r.Decryption_ns = td1 - td0;

            if (!r.Failed && (mlen != cfg->payload_len || memcmp(m, cfg->payload, cfg->payload_len) != 0))
                r.Failed = 1;
        }

        uint64_t t_end = now_ns_monotonic_raw();
        r.Total_ns = t_end - t_begin;
        r.Total_s = (double)r.Total_ns / 1e9;
        r.Peak_Alloc_KB = peak_rss_kb();

        EVP_PKEY_free(srv);
        EVP_PKEY_free(cli);

        if (i >= cfg->warmup) csv_write_row(csv, &r);
    }

    free(c);
    free(m);
}